1. В каких ситуациях применяются типы std::pair std::tuple?
std::pair и std::tuple удобны, если функция возвращает несколько значений разных типов. Класс pair интерпретирует два значения как одно целое. Можно обрабатывать значения, являющиеся элементами класса pair. Класс Tuple используется для выяснения количества элементов, для распознавания типа какого-нибудь элемента, для доступа к элементам. Шаблонная функция make_pair позволяет создавать пары значений, не указывая типы элементов явно. Шаблонная функция make_tuple позволяет создать кортеж значений без явного указания их типов

2. Когда следует использовать контейнер std::array?
std::array удобен для работы с последовательностью из фиксированного числа элементов. Так как память для него выделяется на стеке, это ускоряет работу, нет дополнительных выделений памяти и существует прямой доступ к элементам по индексу

3. Когда следует использовать контейнер std::vector?
std::vector - управляет элементами которые хранятся в динамическим массиве, обеспечивает доступ к элементу за константное время. Высокопроизводительны при вставке и удалении в конце. Вывод: если нужен динамический массив со вставкой преимущественно в конец - используй вектор

4. Когда следует использовать контейнер std::deque?
std::deque - динамический массив, который может расти и в начале, и в конце. Страничная структура памяти. Высокопроизводителен при вставке и в начало, и в конец. Лучше не ссылаться на элементы контейнера, т.к. будет допольнительный расход памяти из-за страничной реализации

5. Когда следует использовать контейнер std::list?
std::list - двусвязный список. Не предоставляет произвольный доступ к элементам(проходы по цепочке, согласно указателям на соседние элементы). Вставка и удаление за константное время из любой позиции в контейнере. Все указатели, ссылки, итераторы остаются корректными после удаления элемента. Итераторы двунаправленные

6. Когда следует использовать контейнер std::forward_list?
std::forward_list - односвязный список. Не предоставяляет произвольный доступ к элементам, проход по цепочке (однонаправленный итератор). Вставка и удаление за константное время из любой позиции контейнера (т.к. не надо переприсваивать значения остальных элементов). Все указатели, ссылки, итераторы остаются корректными после удаления элемента. Экономнее по памяти по сравнению с list

7. Какие адаптеры контейнеров есть в стандартной библиотеке?
Адаптеры: stack управляет по принципу - последним вошел, первым вышел (LIFO); queue - первым вошел, первым вышел(FIFO); priority_queue - как очередь, только дополнительно сортирует элементы, сортировка задается программистом (FIFO + sort)

8. Когда следует использовать контейнер circular buffer из Boost?
Если объём доступной памяти ограничен, и нужно предотвратить произвольный рост контейнера. Или если идет непрерывный поток данных, и старые данные становятся ненужными по мере появления новых. Память автоматически используется повторно путем перезаписи старых данных

9. Почему контейнер circular buffer из Boost не может войти в стандарт?
Элемент, который добавлен позже по времени, может стоять в памяти левее, чем более ранний, потому что это круговой контейнер, что противоречит концепции стандартной библиотеки

10. Какие типы данных для работы с многомерными массивами вы можете назвать?
Обычный двумерный массив, вектор векторов, std::valarray представим как многомерный массив, Boost.Multi_array